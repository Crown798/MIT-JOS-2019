>Exercise 1. In the file kern/pmap.c, you must implement code for the following functions (probably in the order given).
- boot_alloc()
- mem_init() (only up to the call to check_page_free_list(1))
- page_init()
- page_alloc()
- page_free()
>check_page_free_list() and check_page_alloc() test your physical page allocator. 

要求：完善 kern/pmap.c 中的函数，实现物理内存分配器。

# 分析

物理内存初始化的部分流程： 
1. 进入内核后首先调用的是i386_init()，该函数会调用mem_init()
2. mem_init()首先调用i386_detect_memory()来计算有多少可用的物理内存页保存到npages和npages_basemem中
3. 调用boot_alloc(PGSIZE)给kern_pgdir 分配一页空间，并进行相应设置
4. boot_alloc(npages * sizeof(struct PageInfo)) 给物理页管理表数组 pages 分配相应空间
5. page_init() 初始化物理页已分配、未分配情况
6. check_page_free_list(1)、check_page_alloc()、check_page() 检查

进入内核入口函数i386_init()时的物理内存分布如下：

![图1](https://github.com/Crown798/MIT-JOS-2019/blob/master/Lab2/images/1.png?raw=true)

执行完mem_init()后的物理内存如下：

![图2](https://github.com/Crown798/MIT-JOS-2019/blob/master/Lab2/images/2.png?raw=true)

至此编译启动后，check_page_free_list() and check_page_alloc() 会输出测试成功信息。

# 代码
```
void
i386_init(void)
{
	extern char edata[], end[];

	// Before doing anything else, complete the ELF loading process.
	// Clear the uninitialized global data (BSS) section of our program.
	// This ensures that all static/global variables start out zero.
	memset(edata, 0, end - edata);

	// Initialize the console.
	// Can't call cprintf until after we do this!
	cons_init();

	cprintf("6828 decimal is %o octal!\n", 6828);

	// Lab 2 memory management initialization functions
	mem_init();

	while (1)
		monitor(NULL);
}
```

```
static void *
boot_alloc(uint32_t n)
{
	static char *nextfree;	// virtual address of next byte of free memory
	char *result;

	// Initialize nextfree if this is the first time.
	// 'end' is a magic symbol automatically generated by the linker,
	// which points to the end of the kernel's bss segment:
	// the first virtual address that the linker did *not* assign
	// to any kernel code or global variables.
	if (!nextfree) {
		extern char end[];
		nextfree = ROUNDUP((char *) end, PGSIZE);
	}

	// Allocate a chunk large enough to hold 'n' bytes, then update
	// nextfree.  Make sure nextfree is kept aligned
	// to a multiple of PGSIZE.
	//
	// LAB 2: Your code here.
	result = nextfree;
    nextfree = ROUNDUP((char *)result + n, PGSIZE);
        //cprintf("boot_alloc memory at %x, next memory allocate at %x\n", result, nextfree);
    return result;
	    //return NULL;
}
```

```
void
mem_init(void)
{
	uint32_t cr0;
	size_t n;

	// Find out how much memory the machine has (npages & npages_basemem).
	i386_detect_memory();

	//////////////////////////////////////////////////////////////////////
	// create initial page directory.
	kern_pgdir = (pde_t *) boot_alloc(PGSIZE);
	memset(kern_pgdir, 0, PGSIZE);

	//////////////////////////////////////////////////////////////////////
	// Recursively insert PD in itself as a page table, to form
	// a virtual page table at virtual address UVPT.
	// (For now, you don't have understand the greater purpose of the
	// following line.)

	// Permissions: kernel R, user R
	kern_pgdir[PDX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;

	//////////////////////////////////////////////////////////////////////
	// Allocate an array of npages 'struct PageInfo's and store it in 'pages'.
	// The kernel uses this array to keep track of physical pages: for
	// each physical page, there is a corresponding struct PageInfo in this
	// array.  'npages' is the number of physical pages in memory.  Use memset
	// to initialize all fields of each struct PageInfo to 0.
	// Your code goes here:
	pages = (struct PageInfo *) boot_alloc(npages * sizeof(struct PageInfo));
	memset(pages, 0, npages * sizeof(struct PageInfo));

	//////////////////////////////////////////////////////////////////////
	// Now that we've allocated the initial kernel data structures, we set
	// up the list of free physical pages. Once we've done so, all further
	// memory management will go through the page_* functions. In
	// particular, we can now map memory using boot_map_region
	// or page_insert
	page_init();

	check_page_free_list(1);
	check_page_alloc();
	check_page();
    ……
}
```

实现page_init时注意，已经使用的物理空间从下到上为：
- unused
- pages (npages * sizeof(struct PageInfo))
- kern_pgdir (PGSIZE)
- kern_data_and_text
- IO hole
- unused (including aborted kernel_elf and boot_code)
- real-mode IDT and BIOS structures (PGSIZE)
```
void
page_init(void)
{
	// The example code here marks all physical pages as free.
	// However this is not truly the case.  What memory is free?
	//  1) Mark physical page 0 as in use.
	//     This way we preserve the real-mode IDT and BIOS structures
	//     in case we ever need them.  (Currently we don't, but...)
	//  2) The rest of base memory, [PGSIZE, npages_basemem * PGSIZE)
	//     is free.
	//  3) Then comes the IO hole [IOPHYSMEM, EXTPHYSMEM), which must
	//     never be allocated.
	//  4) Then extended memory [EXTPHYSMEM, ...).
	//     Some of it is in use, some is free. Where is the kernel
	//     in physical memory?  Which pages are already in use for
	//     page tables and other data structures?
	//
	// Change the code to reflect this.
	// NB: DO NOT actually touch the physical memory corresponding to
	// free pages!
	size_t i;
	size_t io_hole_start_page = (size_t) IOPHYSMEM / PGSIZE;
	size_t kernel_used_page = (size_t) PADDR(boot_alloc(0)) / PGSIZE;
	for (i = 0; i < npages; i++) {
		if(i == 0) {
			pages[i].pp_ref = 1;
			pages[i].pp_link = NULL;
		}
		else if(i >= io_hole_start_page && i < kernel_used_page) {
			pages[i].pp_ref = 1;
			pages[i].pp_link = NULL;
		}
		else {
			pages[i].pp_ref = 0;
			pages[i].pp_link = page_free_list;
			page_free_list = &pages[i];
		}
	}
}
```

```
struct PageInfo *
page_alloc(int alloc_flags)
{
	// Fill this function in
	if(page_free_list == NULL) return NULL;
	struct PageInfo *result = page_free_list;
	page_free_list = page_free_list->pp_link;
	result->pp_link = NULL;
	if (alloc_flags & ALLOC_ZERO) {
		memset(page2kva(result), 0, PGSIZE);
	}
	return result;
}
```

```
void
page_free(struct PageInfo *pp)
{
	// Fill this function in
	// Hint: You may want to panic if pp->pp_ref is nonzero or
	// pp->pp_link is not NULL.
	if(pp->pp_ref || pp->pp_link) {
		panic("page_free: pp->pp_ref is nonzero or pp->pp_link is not NULL.\n");
	}
	pp->pp_link = page_free_list;
	page_free_list = pp;
}
```